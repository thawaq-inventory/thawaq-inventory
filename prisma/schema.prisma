// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Branch/Franchise Management
enum BranchType {
  KITCHEN
  BRANCH
  WAREHOUSE
}

model Branch {
  id          String   @id @default(uuid())
  name        String   // "Downtown", "Mall Location", etc.
  code        String   @unique // Short code like "DT", "ML"
  type        BranchType @default(BRANCH) // Kitchen, Branch, Warehouse
  address     String?
  phone       String?
  email       String?
  isActive    Boolean  @default(true)
  
  // Geolocation for clock-in verification
  latitude    Float?    // GPS latitude for geofencing
  longitude   Float?    // GPS longitude for geofencing
  geoRadius   Float     @default(200) // Radius in meters for clock-in validity (default 200m)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  // Legacy single-branch users
  users       User[] @relation("UserPrimaryBranch")
  
  // New many-to-many users
  userBranches UserBranch[]
  
  products    Product[]
  shifts      Shift[]
  locations   Location[]
  inventoryLogs InventoryLog[]
  wasteLogs   WasteLog[]
  expenses    Expense[]
  payrollTransactions PayrollTransaction[]
  clockEntries ClockEntry[]
  
  // New Inventory Relations
  inventoryLevels InventoryLevel[]
  sourceTransactions InventoryTransaction[] @relation("SourceBranch")
  destTransactions   InventoryTransaction[] @relation("DestBranch")
  transfersFrom      TransferRequest[]      @relation("TransferFromBranch")
  transfersTo        TransferRequest[]      @relation("TransferToBranch")
}

model User {
  id        String   @id @default(uuid())
  name      String
  username  String   @unique // For login
  password  String              // Hashed password
  pinCode   String?             // Optional: Simple auth for iPad (allows duplicates)
  role      String   @default("EMPLOYEE") // ADMIN or EMPLOYEE
  isActive  Boolean  @default(true)        // Enable/disable account
  
  // Multi-branch support
  // Legacy single branch (kept for backward compatibility)
  branch      Branch?  @relation("UserPrimaryBranch", fields: [branchId], references: [id])
  branchId    String?  // Null for super admins
  isSuperAdmin Boolean @default(false)  // Can manage all branches
  
  // New many-to-many branch assignments
  userBranches UserBranch[]
  
  // Payroll fields
  cliqAlias String?  // CliQ alias for instant transfers (mobile/email)
  hourlyRate Float?  @default(5.0)  // Hourly rate in JOD
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  logs              InventoryLog[]
  wasteLogs         WasteLog[]
  productionBatches ProductionBatch[]
  receivingBatches  ReceivingBatch[]
  expensesSubmitted Expense[] @relation("ExpensesSubmitted")
  expensesReviewed  Expense[] @relation("ExpensesReviewed")
  sessions          Session[]
  shifts            Shift[]
  shiftTemplates    ShiftTemplate[]
  payrollTransactions PayrollTransaction[]
  clockEntries      ClockEntry[]
  
  // New Inventory Relations
  inventoryTransactions InventoryTransaction[]
}

model Product {
  id          String   @id @default(uuid())
  name        String
  sku         String?  @unique
  description String?
  
  // Branch assignment
  // Branch assignment (Optional for Global Products)
  branch      Branch?   @relation(fields: [branchId], references: [id])
  branchId    String?
  
  // Inventory
  stockLevel  Float    @default(0)
  unit        String   @default("UNIT") // kg, pcs, etc.
  purchaseUnit     String?  // e.g. "Case", "Sack"
  conversionFactor Float    @default(1) // e.g. 24 cans per case
  minStock    Float    @default(0) // Reorder point
  maxStock    Float    @default(0) // Par level maximum
  
  // Financials
  cost        Float    @default(0)
  price       Float    @default(0)

  // Foodics Integration
  foodicsId   String?  @unique
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  logs        InventoryLog[]
  invoiceItems InvoiceItem[]
  locationStocks LocationStock[]
  stockTransfers StockTransfer[]
  wasteLogs   WasteLog[]
  recipeIngredients RecipeIngredient[]
  productionBatchesProduced ProductionBatch[] @relation("ProducedItems")
  productionItems ProductionItem[]
  receivingItems ReceivingItem[]
  
  // New Inventory Relations
  inventoryLevels InventoryLevel[]
  inventoryTransactions InventoryTransaction[]
  transferItems TransferItem[]
}

// ... (Existing models like InventoryLog, FoodicsConfig, Accounting models remain unchanged)

model InventoryLog {
  id            String   @id @default(uuid())
  
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  
  branch        Branch   @relation(fields: [branchId], references: [id])
  branchId      String
  
  changeAmount  Float    // +5, -2, etc.
  reason        String   // "SALE", "RESTOCK", "WASTE", "ADJUSTMENT"
  
  user          User?    @relation(fields: [userId], references: [id])
  userId        String?
  
  createdAt     DateTime @default(now())
}

model FoodicsConfig {
  id           String   @id @default(uuid())
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  updatedAt    DateTime @updatedAt
}

// Accounting Models

model Vendor {
  id          String    @id @default(uuid())
  name        String
  email       String?
  phone       String?
  address     String?
  taxId       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  invoices    Invoice[]
  receivingBatches ReceivingBatch[]
}

model Account {
  id              String          @id @default(uuid())
  code            String          @unique
  name            String
  type            String          // ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE
  description     String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  journalEntries  JournalEntryLine[]
  expenseCategoriesDebit  ExpenseCategory[] @relation("ExpenseDebitAccount")
  expenseCategoriesCredit ExpenseCategory[] @relation("ExpenseCreditAccount")
  expensesDebit   Expense[] @relation("ExpenseDebit")
  expensesCredit  Expense[] @relation("ExpenseCredit")
  mappings        AccountingMapping[]
}

model AccountingMapping {
  id        String   @id @default(uuid())
  eventKey  String   @unique // e.g. "WASTE_EXPENSE", "SALES_FOOD"
  account   Account  @relation(fields: [accountId], references: [id])
  accountId String
  
  description String?
  updatedAt DateTime @updatedAt
}

model JournalEntry {
  id          String              @id @default(uuid())
  date        DateTime            @default(now())
  description String
  reference   String?             // Invoice number, etc.
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  lines       JournalEntryLine[]
  expense     Expense?
}

model JournalEntryLine {
  id              String        @id @default(uuid())
  journalEntry    JournalEntry  @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)
  journalEntryId  String
  account         Account       @relation(fields: [accountId], references: [id])
  accountId       String
  debit           Float         @default(0)
  credit          Float         @default(0)
}

model Invoice {
  id          String   @id @default(uuid())
  invoiceNumber String? @unique
  vendor      Vendor   @relation(fields: [vendorId], references: [id])
  vendorId    String
  date        DateTime @default(now())
  dueDate     DateTime?
  amount      Float
  taxAmount   Float    @default(0)
  totalAmount Float
  description String?
  imageUrl    String?  // Path to scanned invoice image
  status      String   @default("UNPAID") // UNPAID, PAID, PARTIAL
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  items       InvoiceItem[]
}

model InvoiceItem {
  id          String   @id @default(uuid())
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId   String
  product     Product? @relation(fields: [productId], references: [id])
  productId   String?
  description String
  quantity    Float
  unitPrice   Float
  amount      Float
}

// New Multi-Branch Core Models

// Authentic Source of Truth for quantity
model InventoryLevel {
  id              String   @id @default(uuid())
  productId       String
  branchId        String   // "Location" in user terms
  quantityOnHand  Float    @default(0)
  reorderPoint    Float    @default(0)
  
  product         Product  @relation(fields: [productId], references: [id])
  branch          Branch   @relation(fields: [branchId], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([productId, branchId])
  @@index([branchId])
}

enum TransactionType {
  PURCHASE_IN
  TRANSFER_OUT
  TRANSFER_IN
  WASTE
  SALE
  ADJUSTMENT
}

model InventoryTransaction {
  id              String   @id @default(uuid())
  type            TransactionType
  
  sourceBranchId  String?  // Null for Purchase/Adjustment
  destBranchId    String?  // Null for Waste/Sale
  
  productId       String
  quantity        Float
  
  userId          String
  timestamp       DateTime @default(now())
  notes           String?

  // Relations
  product         Product @relation(fields: [productId], references: [id])
  user            User    @relation(fields: [userId], references: [id])
  sourceBranch    Branch? @relation("SourceBranch", fields: [sourceBranchId], references: [id])
  destBranch      Branch? @relation("DestBranch", fields: [destBranchId], references: [id])
  
  @@index([sourceBranchId])
  @@index([destBranchId])
  @@index([productId])
  @@index([timestamp])
}

enum TransferStatus {
  REQUESTED
  IN_TRANSIT
  RECEIVED
  REJECTED
}

model TransferRequest {
  id              String         @id @default(uuid())
  fromBranchId    String
  toBranchId      String
  status          TransferStatus @default(REQUESTED)
  
  notes           String?
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  // Relations
  fromBranch      Branch         @relation("TransferFromBranch", fields: [fromBranchId], references: [id])
  toBranch        Branch         @relation("TransferToBranch", fields: [toBranchId], references: [id])
  items           TransferItem[]
}

model TransferItem {
  id              String          @id @default(uuid())
  requestId       String
  productId       String
  quantity        Float
  
  request         TransferRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  product         Product         @relation(fields: [productId], references: [id])
}

// ... (Existing legacy Location, LocationStock, StockTransfer models kept for data safety, can be deprecated)

// Advanced Inventory Features

// 1. Multi-Location Support (Legacy - Consider migrating to Branch/InventoryLevel)
model Location {
  id          String   @id @default(uuid())
  name        String
  address     String?
  phone       String?
  isActive    Boolean  @default(true)
  
  branch      Branch   @relation(fields: [branchId], references: [id])
  branchId    String
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  stocks      LocationStock[]
  transfersFrom StockTransfer[] @relation("TransferFrom")
  transfersTo   StockTransfer[] @relation("TransferTo")
  wasteLogs   WasteLog[]
  productionBatches ProductionBatch[]
  receivingBatches ReceivingBatch[]
}

model LocationStock {
  id          String   @id @default(uuid())
  location    Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  locationId  String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   String
  stockLevel  Float    @default(0)
  
  @@unique([locationId, productId])
}

model StockTransfer {
  id            String   @id @default(uuid())
  fromLocation  Location @relation("TransferFrom", fields: [fromLocationId], references: [id])
  fromLocationId String
  toLocation    Location @relation("TransferTo", fields: [toLocationId], references: [id])
  toLocationId  String
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  quantity      Float
  notes         String?
  status        String   @default("PENDING") // PENDING, COMPLETED, CANCELLED
  createdAt     DateTime @default(now())
  completedAt   DateTime?
}

// 2. Waste Tracking
model WasteLog {
  id            String   @id @default(uuid())
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  
  branch        Branch   @relation(fields: [branchId], references: [id])
  branchId      String
  
  quantity      Float
  reason        String   // EXPIRED, DAMAGED, OVER_PREP, SPOILED, OTHER
  costImpact    Float    // Calculated cost of waste
  notes         String?
  location      Location? @relation(fields: [locationId], references: [id])
  locationId    String?
  user          User?    @relation(fields: [userId], references: [id])
  userId        String?
  createdAt     DateTime @default(now())
}

// 3. Recipe & Menu Costing
model Recipe {
  id            String   @id @default(uuid())
  name          String
  description   String?
  category      String?
  servingSize   Float    @default(1)
  targetCost    Float?   // Target cost per serving
  sellingPrice  Float?   // Menu price
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  ingredients   RecipeIngredient[]
  productionBatches ProductionBatch[]
}

model RecipeIngredient {
  id          String   @id @default(uuid())
  recipe      Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId    String
  product     Product  @relation(fields: [productId], references: [id])
  productId   String
  quantity    Float    // Amount needed per serving
  unit        String   // Should match product unit
  
  @@unique([recipeId, productId])
}

// 4. Production/Prep Module
model ProductionBatch {
  id              String   @id @default(uuid())
  recipe          Recipe?  @relation(fields: [recipeId], references: [id])
  recipeId        String?
  outputProduct   Product  @relation("ProducedItems", fields: [outputProductId], references: [id])
  outputProductId String
  quantityProduced Float
  notes           String?
  location        Location? @relation(fields: [locationId], references: [id])
  locationId      String?
  user            User?    @relation(fields: [userId], references: [id])
  userId          String?
  createdAt       DateTime @default(now())
  
  ingredients     ProductionItem[]
}

model ProductionItem {
  id              String   @id @default(uuid())
  batch           ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId         String
  product         Product  @relation(fields: [productId], references: [id])
  productId       String
  quantityUsed    Float
}

// 5. Enhanced Receiving
model ReceivingBatch {
  id              String   @id @default(uuid())
  vendor          Vendor?  @relation(fields: [vendorId], references: [id])
  vendorId        String?
  deliveryDate    DateTime @default(now())
  batchNumber     String?  // Supplier batch/lot number
  notes           String?
  photoUrl        String?  // Uploaded delivery note photo
  location        Location? @relation(fields: [locationId], references: [id])
  locationId      String?
  user            User?    @relation(fields: [userId], references: [id])
  userId          String?
  createdAt       DateTime @default(now())
  
  items           ReceivingItem[]
}

model ReceivingItem {
  id              String   @id @default(uuid())
  batch           ReceivingBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId         String
  product         Product  @relation(fields: [productId], references: [id])
  productId       String
  quantity        Float
  expiryDate      DateTime?
  lotNumber       String?
  qualityOk       Boolean  @default(true)
  quantityOk      Boolean  @default(true)
  packagingOk     Boolean  @default(true)
  notes           String?
}

// Expense Management
model ExpenseCategory {
  id              String    @id @default(uuid())
  name            String    @unique
  description     String?
  debitAccountId  String?
  creditAccountId String?
  
  debitAccount    Account?  @relation("ExpenseDebitAccount", fields: [debitAccountId], references: [id])
  creditAccount   Account?  @relation("ExpenseCreditAccount", fields: [creditAccountId], references: [id])
  expenses        Expense[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Expense {
  id                String           @id @default(uuid())
  amount            Float
  taxRate           Float            @default(0) // Tax percentage (0, 5, 10, 16, etc.)
  taxAmount         Float            @default(0) // Calculated tax amount
  totalAmount       Float            @default(0) // Amount + taxAmount
  description       String?
  expenseDate       DateTime         @default(now())
  photoUrl          String?          // Optional receipt photo
  notes             String?
  
  branch            Branch           @relation(fields: [branchId], references: [id])
  branchId          String
  
  categoryId        String?
  customCategory    String?          // If "Other" selected
  
  status            String           @default("PENDING") // PENDING, APPROVED, REJECTED
  rejectionReason   String?
  
  submittedById     String
  reviewedById      String?
  reviewedAt        DateTime?
  
  // Account mapping (can be edited during approval)
  debitAccountId    String?
  creditAccountId   String?
  
  journalEntryId    String?          @unique // Created on approval
  
  category          ExpenseCategory? @relation(fields: [categoryId], references: [id])
  submittedBy       User             @relation("ExpensesSubmitted", fields: [submittedById], references: [id])
  reviewedBy        User?            @relation("ExpensesReviewed", fields: [reviewedById], references: [id])
  debitAccount      Account?         @relation("ExpenseDebit", fields: [debitAccountId], references: [id])
  creditAccount     Account?         @relation("ExpenseCredit", fields: [creditAccountId], references: [id])
  journalEntry      JournalEntry?    @relation(fields: [journalEntryId], references: [id])
  
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
}

// Authentication Sessions
model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

// Shift Management
model Shift {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  branch    Branch   @relation(fields: [branchId], references: [id])
  branchId  String
  
  date      DateTime // The date of the shift
  startTime String   // Format: "HH:MM" (e.g., "09:00")
  endTime   String   // Format: "HH:MM" (e.g., "17:00")
  role      String   // Position/role for this shift (e.g., "Manager", "Server", "Chef")
  notes     String?  // Optional additional notes
  status    String   @default("SCHEDULED") // SCHEDULED, COMPLETED, CANCELLED, NO_SHOW
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ShiftTemplate {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  dayOfWeek  Int      // 0 = Monday, 6 = Sunday
  startTime  String   // Format: "HH:MM"
  endTime    String   // Format: "HH:MM"
  role       String   // Position/role
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// Payroll Management
model PayrollTransaction {
  id              String   @id @default(uuid())
  employee        User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeId      String
  
  branch          Branch   @relation(fields: [branchId], references: [id])
  branchId        String
  
  // Calculation details
  totalHours      Float
  hourlyRate      Float
  finalAmount     Float    // totalHours Ã— hourlyRate
  
  // Pay period
  periodStart     DateTime
  periodEnd       DateTime
  
  // Bank integration
  transactionId   String?  // Staq API transaction ID
  reference       String?  // Payment reference number
  status          String   @default("waiting_bank_approval") // waiting_bank_approval, approved, rejected, failed
  
  // Banking details (employee account)
  accountNumber   String?
  bankCode        String?
  
  // Metadata
  notes           String?
  errorMessage    String?  // If transaction fails
  approvedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// Junction table for many-to-many user-branch relationship
model UserBranch {
  id        String   @id @default(uuid())
  userId    String
  branchId  String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  branch    Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([userId, branchId])
  @@index([userId])
  @@index([branchId])
}

// Clock In/Out Tracking
model ClockEntry {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  branchId      String
  branch        Branch    @relation(fields: [branchId], references: [id])
  
  clockInTime   DateTime
  clockOutTime  DateTime?
  
  // Location verification
  clockInLat    Float?
  clockInLng    Float?
  clockOutLat   Float?
  clockOutLng   Float?
  
  // Source of clock entry (for future face scanner integration)
  clockInSource   String  @default("app")  // "app", "face_scanner", "manual"
  clockOutSource  String?
  
  notes         String?
  totalHours    Float?    // Calculated on clock out
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([userId])
  @@index([branchId])
  @@index([clockInTime])
}
