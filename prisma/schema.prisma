// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Branch/Franchise Management
model Branch {
  id          String   @id @default(uuid())
  name        String   // "Downtown", "Mall Location", etc.
  code        String   @unique // Short code like "DT", "ML"
  address     String?
  phone       String?
  email       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  // Legacy single-branch users
  users       User[] @relation("UserPrimaryBranch")
  
  // New many-to-many users
  userBranches UserBranch[]
  
  products    Product[]
  shifts      Shift[]
  locations   Location[]
  inventoryLogs InventoryLog[]
  wasteLogs   WasteLog[]
  expenses    Expense[]
  payrollTransactions PayrollTransaction[]
}

model User {
  id        String   @id @default(uuid())
  name      String
  username  String   @unique // For login
  password  String              // Hashed password
  pinCode   String?  @unique    // Optional: Simple auth for iPad (legacy)
  role      String   @default("EMPLOYEE") // ADMIN or EMPLOYEE
  isActive  Boolean  @default(true)        // Enable/disable account
  
  // Multi-branch support
  // Legacy single branch (kept for backward compatibility)
  branch      Branch?  @relation("UserPrimaryBranch", fields: [branchId], references: [id])
  branchId    String?  // Null for super admins
  isSuperAdmin Boolean @default(false)  // Can manage all branches
  
  // New many-to-many branch assignments
  userBranches UserBranch[]
  
  // Payroll fields
  cliqAlias String?  // CliQ alias for instant transfers (mobile/email)
  hourlyRate Float?  @default(5.0)  // Hourly rate in JOD
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  logs              InventoryLog[]
  wasteLogs         WasteLog[]
  productionBatches ProductionBatch[]
  receivingBatches  ReceivingBatch[]
  expensesSubmitted Expense[] @relation("ExpensesSubmitted")
  expensesReviewed  Expense[] @relation("ExpensesReviewed")
  sessions          Session[]
  shifts            Shift[]
  shiftTemplates    ShiftTemplate[]
  payrollTransactions PayrollTransaction[]
}

model Product {
  id          String   @id @default(uuid())
  name        String
  sku         String?  @unique
  description String?
  
  // Branch assignment
  branch      Branch   @relation(fields: [branchId], references: [id])
  branchId    String
  
  // Inventory
  stockLevel  Float    @default(0)
  unit        String   @default("UNIT") // kg, pcs, etc.
  minStock    Float    @default(0) // Reorder point
  maxStock    Float    @default(0) // Par level maximum
  
  // Financials
  cost        Float    @default(0)
  price       Float    @default(0)

  // Foodics Integration
  foodicsId   String?  @unique
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  logs        InventoryLog[]
  invoiceItems InvoiceItem[]
  locationStocks LocationStock[]
  stockTransfers StockTransfer[]
  wasteLogs   WasteLog[]
  recipeIngredients RecipeIngredient[]
  productionBatchesProduced ProductionBatch[] @relation("ProducedItems")
  productionItems ProductionItem[]
  receivingItems ReceivingItem[]
}

model InventoryLog {
  id            String   @id @default(uuid())
  
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  
  branch        Branch   @relation(fields: [branchId], references: [id])
  branchId      String
  
  changeAmount  Float    // +5, -2, etc.
  reason        String   // "SALE", "RESTOCK", "WASTE", "ADJUSTMENT"
  
  user          User?    @relation(fields: [userId], references: [id])
  userId        String?
  
  createdAt     DateTime @default(now())
}

model FoodicsConfig {
  id           String   @id @default(uuid())
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  updatedAt    DateTime @updatedAt
}

// Accounting Models

model Vendor {
  id          String    @id @default(uuid())
  name        String
  email       String?
  phone       String?
  address     String?
  taxId       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  invoices    Invoice[]
  receivingBatches ReceivingBatch[]
}

model Account {
  id              String          @id @default(uuid())
  code            String          @unique
  name            String
  type            String          // ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE
  description     String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  journalEntries  JournalEntryLine[]
  expenseCategoriesDebit  ExpenseCategory[] @relation("ExpenseDebitAccount")
  expenseCategoriesCredit ExpenseCategory[] @relation("ExpenseCreditAccount")
  expensesDebit   Expense[] @relation("ExpenseDebit")
  expensesCredit  Expense[] @relation("ExpenseCredit")
}

model JournalEntry {
  id          String              @id @default(uuid())
  date        DateTime            @default(now())
  description String
  reference   String?             // Invoice number, etc.
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  lines       JournalEntryLine[]
  expense     Expense?
}

model JournalEntryLine {
  id              String        @id @default(uuid())
  journalEntry    JournalEntry  @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)
  journalEntryId  String
  account         Account       @relation(fields: [accountId], references: [id])
  accountId       String
  debit           Float         @default(0)
  credit          Float         @default(0)
}

model Invoice {
  id          String   @id @default(uuid())
  invoiceNumber String? @unique
  vendor      Vendor   @relation(fields: [vendorId], references: [id])
  vendorId    String
  date        DateTime @default(now())
  dueDate     DateTime?
  amount      Float
  taxAmount   Float    @default(0)
  totalAmount Float
  description String?
  imageUrl    String?  // Path to scanned invoice image
  status      String   @default("UNPAID") // UNPAID, PAID, PARTIAL
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  items       InvoiceItem[]
}

model InvoiceItem {
  id          String   @id @default(uuid())
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId   String
  product     Product? @relation(fields: [productId], references: [id])
  productId   String?
  description String
  quantity    Float
  unitPrice   Float
  amount      Float
}

// Advanced Inventory Features

// 1. Multi-Location Support
model Location {
  id          String   @id @default(uuid())
  name        String
  address     String?
  phone       String?
  isActive    Boolean  @default(true)
  
  branch      Branch   @relation(fields: [branchId], references: [id])
  branchId    String
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  stocks      LocationStock[]
  transfersFrom StockTransfer[] @relation("TransferFrom")
  transfersTo   StockTransfer[] @relation("TransferTo")
  wasteLogs   WasteLog[]
  productionBatches ProductionBatch[]
  receivingBatches ReceivingBatch[]
}

model LocationStock {
  id          String   @id @default(uuid())
  location    Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  locationId  String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   String
  stockLevel  Float    @default(0)
  
  @@unique([locationId, productId])
}

model StockTransfer {
  id            String   @id @default(uuid())
  fromLocation  Location @relation("TransferFrom", fields: [fromLocationId], references: [id])
  fromLocationId String
  toLocation    Location @relation("TransferTo", fields: [toLocationId], references: [id])
  toLocationId  String
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  quantity      Float
  notes         String?
  status        String   @default("PENDING") // PENDING, COMPLETED, CANCELLED
  createdAt     DateTime @default(now())
  completedAt   DateTime?
}

// 2. Waste Tracking
model WasteLog {
  id            String   @id @default(uuid())
  product       Product  @relation(fields: [productId], references: [id])
  productId     String
  
  branch        Branch   @relation(fields: [branchId], references: [id])
  branchId      String
  
  quantity      Float
  reason        String   // EXPIRED, DAMAGED, OVER_PREP, SPOILED, OTHER
  costImpact    Float    // Calculated cost of waste
  notes         String?
  location      Location? @relation(fields: [locationId], references: [id])
  locationId    String?
  user          User?    @relation(fields: [userId], references: [id])
  userId        String?
  createdAt     DateTime @default(now())
}

// 3. Recipe & Menu Costing
model Recipe {
  id            String   @id @default(uuid())
  name          String
  description   String?
  category      String?
  servingSize   Float    @default(1)
  targetCost    Float?   // Target cost per serving
  sellingPrice  Float?   // Menu price
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  ingredients   RecipeIngredient[]
  productionBatches ProductionBatch[]
}

model RecipeIngredient {
  id          String   @id @default(uuid())
  recipe      Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId    String
  product     Product  @relation(fields: [productId], references: [id])
  productId   String
  quantity    Float    // Amount needed per serving
  unit        String   // Should match product unit
  
  @@unique([recipeId, productId])
}

// 4. Production/Prep Module
model ProductionBatch {
  id              String   @id @default(uuid())
  recipe          Recipe?  @relation(fields: [recipeId], references: [id])
  recipeId        String?
  outputProduct   Product  @relation("ProducedItems", fields: [outputProductId], references: [id])
  outputProductId String
  quantityProduced Float
  notes           String?
  location        Location? @relation(fields: [locationId], references: [id])
  locationId      String?
  user            User?    @relation(fields: [userId], references: [id])
  userId          String?
  createdAt       DateTime @default(now())
  
  ingredients     ProductionItem[]
}

model ProductionItem {
  id              String   @id @default(uuid())
  batch           ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId         String
  product         Product  @relation(fields: [productId], references: [id])
  productId       String
  quantityUsed    Float
}

// 5. Enhanced Receiving
model ReceivingBatch {
  id              String   @id @default(uuid())
  vendor          Vendor?  @relation(fields: [vendorId], references: [id])
  vendorId        String?
  deliveryDate    DateTime @default(now())
  batchNumber     String?  // Supplier batch/lot number
  notes           String?
  photoUrl        String?  // Uploaded delivery note photo
  location        Location? @relation(fields: [locationId], references: [id])
  locationId      String?
  user            User?    @relation(fields: [userId], references: [id])
  userId          String?
  createdAt       DateTime @default(now())
  
  items           ReceivingItem[]
}

model ReceivingItem {
  id              String   @id @default(uuid())
  batch           ReceivingBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  batchId         String
  product         Product  @relation(fields: [productId], references: [id])
  productId       String
  quantity        Float
  expiryDate      DateTime?
  lotNumber       String?
  qualityOk       Boolean  @default(true)
  quantityOk      Boolean  @default(true)
  packagingOk     Boolean  @default(true)
  notes           String?
}

// Expense Management
model ExpenseCategory {
  id              String    @id @default(uuid())
  name            String    @unique
  description     String?
  debitAccountId  String?
  creditAccountId String?
  
  debitAccount    Account?  @relation("ExpenseDebitAccount", fields: [debitAccountId], references: [id])
  creditAccount   Account?  @relation("ExpenseCreditAccount", fields: [creditAccountId], references: [id])
  expenses        Expense[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Expense {
  id                String           @id @default(uuid())
  amount            Float
  taxRate           Float            @default(0) // Tax percentage (0, 5, 10, 16, etc.)
  taxAmount         Float            @default(0) // Calculated tax amount
  totalAmount       Float            @default(0) // Amount + taxAmount
  description       String?
  expenseDate       DateTime         @default(now())
  photoUrl          String?          // Optional receipt photo
  notes             String?
  
  branch            Branch           @relation(fields: [branchId], references: [id])
  branchId          String
  
  categoryId        String?
  customCategory    String?          // If "Other" selected
  
  status            String           @default("PENDING") // PENDING, APPROVED, REJECTED
  rejectionReason   String?
  
  submittedById     String
  reviewedById      String?
  reviewedAt        DateTime?
  
  // Account mapping (can be edited during approval)
  debitAccountId    String?
  creditAccountId   String?
  
  journalEntryId    String?          @unique // Created on approval
  
  category          ExpenseCategory? @relation(fields: [categoryId], references: [id])
  submittedBy       User             @relation("ExpensesSubmitted", fields: [submittedById], references: [id])
  reviewedBy        User?            @relation("ExpensesReviewed", fields: [reviewedById], references: [id])
  debitAccount      Account?         @relation("ExpenseDebit", fields: [debitAccountId], references: [id])
  creditAccount     Account?         @relation("ExpenseCredit", fields: [creditAccountId], references: [id])
  journalEntry      JournalEntry?    @relation(fields: [journalEntryId], references: [id])
  
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
}

// Authentication Sessions
model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

// Shift Management
model Shift {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  branch    Branch   @relation(fields: [branchId], references: [id])
  branchId  String
  
  date      DateTime // The date of the shift
  startTime String   // Format: "HH:MM" (e.g., "09:00")
  endTime   String   // Format: "HH:MM" (e.g., "17:00")
  role      String   // Position/role for this shift (e.g., "Manager", "Server", "Chef")
  notes     String?  // Optional additional notes
  status    String   @default("SCHEDULED") // SCHEDULED, COMPLETED, CANCELLED, NO_SHOW
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ShiftTemplate {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  dayOfWeek  Int      // 0 = Monday, 6 = Sunday
  startTime  String   // Format: "HH:MM"
  endTime    String   // Format: "HH:MM"
  role       String   // Position/role
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// Payroll Management
model PayrollTransaction {
  id              String   @id @default(uuid())
  employee        User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeId      String
  
  branch          Branch   @relation(fields: [branchId], references: [id])
  branchId        String
  
  // Calculation details
  totalHours      Float
  hourlyRate      Float
  finalAmount     Float    // totalHours Ã— hourlyRate
  
  // Pay period
  periodStart     DateTime
  periodEnd       DateTime
  
  // Bank integration
  transactionId   String?  // Staq API transaction ID
  reference       String?  // Payment reference number
  status          String   @default("waiting_bank_approval") // waiting_bank_approval, approved, rejected, failed
  
  // Banking details (employee account)
  accountNumber   String?
  bankCode        String?
  
  // Metadata
  notes           String?
  errorMessage    String?  // If transaction fails
  approvedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// Junction table for many-to-many user-branch relationship
model UserBranch {
  id        String   @id @default(uuid())
  userId    String
  branchId  String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  branch    Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([userId, branchId])
  @@index([userId])
  @@index([branchId])
}
